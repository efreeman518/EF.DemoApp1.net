@page "/user"

@using System.Text.Json
@using System.Security.Claims
@using Blazored.LocalStorage
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication

@inject IAccessTokenProvider AuthorizationService


<AuthorizeView>
    <Authorized>
        <h1>@AuthenticatedUser?.Identity?.Name</h1>

        <h2>Claims</h2>

        @foreach (var claim in AuthenticatedUser?.Claims ?? Array.Empty<Claim>())
        {
            <p class="claim">@(claim.Type): @claim.Value</p>
        }

        <h2>Access token</h2>

        <p id="access-token">@AccessToken?.Value</p>

        <h2>Access token claims</h2>

        @foreach (var claim in GetAccessTokenClaims() ?? new Dictionary<string, object>())
        {
            <p>@(claim.Key): @claim.Value.ToString()</p>
        }

        @if (AccessToken != null)
        {
            <h2>Access token expires</h2>

            <p>Current time: <span id="current-time">@DateTimeOffset.Now</span></p>
            <p id="access-token-expires">@AccessToken.Expires</p>

            <h2>Access token granted scopes (as reported by the API)</h2>

            @foreach (var scope in AccessToken.GrantedScopes)
            {
                <p>Scope: @scope</p>
            }
        }

    </Authorized>
    <NotAuthorized>
        <a href="authentication/login">Login</a>
    </NotAuthorized>
</AuthorizeView>

@code {
    [Inject]
    private ILocalStorageService LocalStorage { get; set; } = null!;

    [CascadingParameter]
    private Task<AuthenticationState> AuthenticationState { get; set; } = null!;

    public ClaimsPrincipal? AuthenticatedUser { get; set; }
    public AccessToken? AccessToken { get; set; }

    protected override async Task OnInitializedAsync()
    {
        //await base.OnInitializedAsync();
        var state = await AuthenticationState;
        var accessTokenResult = await AuthorizationService.RequestAccessToken();

        if (!accessTokenResult.TryGetToken(out var token))
        {
            //throw new InvalidOperationException("Failed to provision the access token.");
        }

        AccessToken = token;

        AuthenticatedUser = state.User;
    }

    protected IDictionary<string, object>? GetAccessTokenClaims()
    {
        if (AccessToken == null)
        {
            return new Dictionary<string, object>();
        }

        // header.payload.signature
        var payload = AccessToken.Value.Split(".")[1];
        var base64Payload = payload.Replace('-', '+').Replace('_', '/')
            .PadRight(payload.Length + (4 - payload.Length % 4) % 4, '=');

        var claims = JsonSerializer.Deserialize<IDictionary<string, object>>(
            Convert.FromBase64String(base64Payload));

        return claims;
    }
}
